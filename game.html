<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hari ng Dama</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 20px;
      background: url("images/backgound2.png") no-repeat center center/cover;
    }

    #profile-section {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
      gap: 12px;
    }

    #profile-section img {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 2px solid #333;
    }

    #controls {
      margin-bottom: 10px;
    }

    button, select, input {
      margin: 2px;
      padding: 6px 10px;
    }

    svg {
      border: 2px solid #333;
      background: #eee;
      touch-action: none;
    }

    .piece {
      cursor: grab;
    }

    #status {
      margin-top: 10px;
      font-weight: bold;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Hari ng Dama</h1>

  <div id="back-btn" style="position:absolute; top:10px; left:10px;">
    <button onclick="goHome()" style="background:none;border:none;cursor:pointer;font-size:40px;color:#000;">â¬…</button>
  </div>

  <div id="profile-section">
    <img id="profile-avatar" src="" alt="Profile Avatar"/>
    <span id="player-name">Player</span>
  </div>

  <div id="controls">
    <button onclick="startVsAI()">START GAME</button>
    <select id="aiLevel">
      <option value="easy">Easy</option>
      <option value="medium">Medium</option>
      <option value="hard">Hard</option>
    </select>
    <button onclick="createLobby()">Create Lobby</button>
    <button onclick="joinLobby()">Join Lobby</button>
    <input id="lobbyCode" placeholder="Lobby Code"/>
  </div>

  <svg id="board" width="560" height="560"></svg>
  <div id="status"></div>

  <script>
    function goHome() {
      window.location.href = "index.html";
    }

    function loadProfileAvatar() {
      const saved = localStorage.getItem("profileAvatar");
      const avatarImg = document.getElementById("profile-avatar");
      avatarImg.src = saved || "https://api.dicebear.com/9.x/pixel-art/svg?seed=default";
    }
    loadProfileAvatar();

    const SIZE = 8, CELL = 70;
    const boardSVG = document.getElementById("board");
    let gameState = initGame();
    let selected = null;
    let currentTurn = "white";
    let aiEnabled = false;
    let aiLevel = "easy";
    let multiplayer = false;
    let socket = null;
    let playerColor = null;

    drawBoard();
    drawPieces();
    updateStatus();

    function initGame() {
      let grid = [];
      for (let r = 0; r < SIZE; r++) {
        grid[r] = [];
        for (let c = 0; c < SIZE; c++) {
          if (r < 3 && (r + c) % 2 === 1) grid[r][c] = { color: "black", king: false };
          else if (r > 4 && (r + c) % 2 === 1) grid[r][c] = { color: "white", king: false };
          else grid[r][c] = null;
        }
      }
      return grid;
    }

    function drawBoard() {
      boardSVG.innerHTML = "";
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          rect.setAttribute("x", c * CELL);
          rect.setAttribute("y", r * CELL);
          rect.setAttribute("width", CELL);
          rect.setAttribute("height", CELL);
          rect.setAttribute("fill", (r + c) % 2 === 0 ? "#fff" : "#555");
          boardSVG.appendChild(rect);
        }
      }
    }

    function drawPieces() {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const piece = gameState[r][c];
          if (piece) {
            const img = document.createElementNS("http://www.w3.org/2000/svg", "image");
            img.setAttribute("x", c * CELL);
            img.setAttribute("y", r * CELL);
            img.setAttribute("width", CELL);
            img.setAttribute("height", CELL);
            img.setAttribute("href", piece.color === "white"
              ? (piece.king ? "images/white-king.png" : "images/white-piece.png")
              : (piece.king ? "images/black-king.png" : "images/black-piece.png"));
            img.style.cursor = "pointer";
            img.addEventListener("click", () => selectPiece(r, c));
            img.addEventListener("touchstart", (e) => { e.preventDefault(); selectPiece(r, c); });
            boardSVG.appendChild(img);
          }
        }
      }
    }

    function selectPiece(r, c) {
      if (gameState[r][c]?.color !== currentTurn) return;
      if (multiplayer && currentTurn !== playerColor) return;
      selected = { r, c };
    }

    boardSVG.addEventListener("click", (e) => {
      if (!selected) return;
      const { r, c } = getCellFromEvent(e);
      attemptMove(selected.r, selected.c, r, c);
    });

    boardSVG.addEventListener("touchstart", (e) => {
      if (!selected) return;
      e.preventDefault();
      const { r, c } = getCellFromEvent(e);
      attemptMove(selected.r, selected.c, r, c);
    });

    function getCellFromEvent(e) {
      const rect = boardSVG.getBoundingClientRect();
      const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
      const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
      return { r: Math.floor(y / CELL), c: Math.floor(x / CELL) };
    }

    function attemptMove(sr, sc, tr, tc) {
      const piece = gameState[sr][sc];
      if (!piece) return;

      const mustCapture = playerMustCapture(currentTurn);
      const moves = legalMoves(sr, sc, mustCapture);
      const found = moves.find(m => m.r === tr && m.c === tc);
      if (!found) return;

      gameState[tr][tc] = piece;
      gameState[sr][sc] = null;
      if (found.capture) gameState[found.capture.r][found.capture.c] = null;

      if ((piece.color === "white" && tr === 0) || (piece.color === "black" && tr === SIZE - 1)) piece.king = true;

      // Multiplayer sync
      if (multiplayer && currentTurn === playerColor) {
        sendMessage({ type: "move", sr, sc, tr, tc, capture: found.capture });
      }

      // Handle multiple captures
      const nextMoves = legalMoves(tr, tc, true).filter(m => m.capture);
      if (found.capture && nextMoves.length > 0) {
        selected = { r: tr, c: tc };
      } else {
        selected = null;
        switchTurn();
      }

      redraw();
    }

    function legalMoves(r, c, mustCapture = false) {
      const piece = gameState[r][c];
      if (!piece) return [];

      const moves = [];
      const captures = [];

      const dirs = piece.king
        ? [[1,1],[1,-1],[-1,1],[-1,-1]]
        : (piece.color === "white" ? [[-1,1],[-1,-1]] : [[1,1],[1,-1]]);

      for (const [dr, dc] of dirs) {
        const nr = r + dr, nc = c + dc;
        if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && !gameState[nr][nc] && !mustCapture)
          moves.push({ r: nr, c: nc });
      }

      for (const [dr, dc] of [[1,1],[1,-1],[-1,1],[-1,-1]]) {
        const nr = r + dr, nc = c + dc;
        if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && gameState[nr][nc] && gameState[nr][nc].color !== piece.color) {
          const jr = nr + dr, jc = nc + dc;
          if (jr >= 0 && jr < SIZE && jc >= 0 && jc < SIZE && !gameState[jr][jc])
            captures.push({ r: jr, c: jc, capture: { r: nr, c: nc } });
        }
      }
      return captures.length > 0 ? captures : moves;
    }

    function playerMustCapture(color) {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (gameState[r][c]?.color === color && legalMoves(r, c, true).some(m => m.capture)) return true;
        }
      }
      return false;
    }

    function switchTurn() {
      if (checkWinner()) return;
      currentTurn = currentTurn === "white" ? "black" : "white";
      selected = null;
      updateStatus();
      if (aiEnabled && currentTurn === "black") setTimeout(aiMove, 500);
    }

    function redraw() { drawBoard(); drawPieces(); }

    function updateStatus() {
      let status = multiplayer
        ? `You are ${playerColor.toUpperCase()} | Turn: ${currentTurn}`
        : (aiEnabled ? `You are White vs AI (Black) | Turn: ${currentTurn}` : `Turn: ${currentTurn}`);
      document.getElementById("status").innerText = status;
    }

    function aiMove() {
      const mustCapture = playerMustCapture("black");
      const moves = [];
      for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) {
        if (gameState[r][c]?.color === "black") {
          legalMoves(r, c, mustCapture).forEach(m => moves.push({ sr: r, sc: c, tr: m.r, tc: m.c }));
        }
      }
      if (moves.length === 0) return;
      const best = moves[Math.floor(Math.random() * moves.length)];
      attemptMove(best.sr, best.sc, best.tr, best.tc);
    }

    function checkWinner() {
      let whitePieces = 0, blackPieces = 0;
      for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) {
        const piece = gameState[r][c];
        if (piece) (piece.color === "white" ? whitePieces++ : blackPieces++);
      }
      if (whitePieces === 0) { alert("ðŸ˜ž YOU LOSE! TRY AGAIN"); resetGame(); return true; }
      if (blackPieces === 0) { alert("ðŸ† YOU WIN!"); resetGame(); return true; }
      return false;
    }

    function startVsAI() {
      aiEnabled = true;
      aiLevel = document.getElementById("aiLevel").value;
      multiplayer = false;
      playerColor = "white";
      resetGame();
    }

    function resetGame() {
      gameState = initGame();
      currentTurn = "white";
      selected = null;
      redraw();
      updateStatus();
    }

    // Multiplayer WebSocket
    function createLobby() { multiplayer = true; aiEnabled = false; playerColor = "white"; connectSocket(true); }
    function joinLobby() { multiplayer = true; aiEnabled = false; playerColor = "black"; connectSocket(false); }

    function connectSocket(isHost) {
      socket = new WebSocket("wss://hari-ng-dama-server-3.onrender.com");

      window.sendMessage = (data) => {
        if (socket.readyState === WebSocket.OPEN) socket.send(JSON.stringify(data));
        else socket.addEventListener("open", () => socket.send(JSON.stringify(data)), { once: true });
      };

      socket.onopen = () => sendMessage({ type: isHost ? "create" : "join", code: document.getElementById("lobbyCode").value });

      socket.onmessage = (msg) => {
        const data = JSON.parse(msg.data);
        if (data.type === "code") {
          alert("Lobby code: " + data.code);
          document.getElementById("lobbyCode").value = data.code;
        } else if (data.type === "move") {
          attemptMove(data.sr, data.sc, data.tr, data.tc);
        } else if (data.type === "error") {
          alert("Error: " + data.message);
        }
      };

      socket.onclose = () => alert("Connection closed.");
      socket.onerror = (err) => console.error("WebSocket error:", err);
    }
  </script>
</body>
</html>
